// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package database

import (
	"context"
	"time"
)

const doesAllianceExist = `-- name: DoesAllianceExist :one
SELECT EXISTS(SELECT 1 FROM alliances WHERE alliance_id = $1 AND region = $2)
`

type DoesAllianceExistParams struct {
	AllianceID string `json:"alliance_id"`
	Region     string `json:"region"`
}

func (q *Queries) DoesAllianceExist(ctx context.Context, arg DoesAllianceExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesAllianceExist, arg.AllianceID, arg.Region)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const doesGuildExist = `-- name: DoesGuildExist :one
SELECT EXISTS(SELECT 1 FROM guilds WHERE guild_id = $1 AND region = $2)
`

type DoesGuildExistParams struct {
	GuildID string `json:"guild_id"`
	Region  string `json:"region"`
}

func (q *Queries) DoesGuildExist(ctx context.Context, arg DoesGuildExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesGuildExist, arg.GuildID, arg.Region)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const doesPlayerExist = `-- name: DoesPlayerExist :one
SELECT EXISTS(SELECT 1 FROM players WHERE player_id = $1 AND region = $2)
`

type DoesPlayerExistParams struct {
	PlayerID string `json:"player_id"`
	Region   string `json:"region"`
}

func (q *Queries) DoesPlayerExist(ctx context.Context, arg DoesPlayerExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesPlayerExist, arg.PlayerID, arg.Region)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllianceHistory = `-- name: GetAllianceHistory :many
SELECT
	g.name,
	g.guild_id,
	gam.first_seen,
	gam.last_seen,
	COALESCE(
    (
	SELECT
		array_to_json(array_agg(row_to_json(p)))
	FROM
		(
		SELECT
			p.player_id,
			p.name,
			GREATEST(gam.first_seen, pgm.first_seen) AS first_seen,
			LEAST(gam.last_seen, pgm.last_seen) AS last_seen
		FROM
			player_guild_memberships pgm
		JOIN 
            players p ON
			pgm.player_id = p.player_id
			AND pgm.region = p.region
		WHERE
			pgm.guild_id = g.guild_id
			AND pgm.region = g.region
			AND pgm.first_seen <= gam.last_seen
			AND pgm.last_seen >= gam.first_seen
		ORDER BY
			pgm.first_seen DESC
        ) p
    ),
	'[]'::JSON
    ) AS players
FROM
	guild_alliance_memberships gam
JOIN
    guilds g ON
	gam.guild_id = g.guild_id
	AND gam.region = g.region
WHERE
	gam.alliance_id = $1 
	AND gam.region = $2
ORDER BY
	gam.first_seen DESC
`

type GetAllianceHistoryParams struct {
	AllianceID string `json:"alliance_id"`
	Region     string `json:"region"`
}

type GetAllianceHistoryRow struct {
	Name      string      `json:"name"`
	GuildID   string      `json:"guild_id"`
	FirstSeen time.Time   `json:"first_seen"`
	LastSeen  time.Time   `json:"last_seen"`
	Players   interface{} `json:"players"`
}

func (q *Queries) GetAllianceHistory(ctx context.Context, arg GetAllianceHistoryParams) ([]GetAllianceHistoryRow, error) {
	rows, err := q.db.Query(ctx, getAllianceHistory, arg.AllianceID, arg.Region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllianceHistoryRow{}
	for rows.Next() {
		var i GetAllianceHistoryRow
		if err := rows.Scan(
			&i.Name,
			&i.GuildID,
			&i.FirstSeen,
			&i.LastSeen,
			&i.Players,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountsOfEntities = `-- name: GetCountsOfEntities :one
SELECT
  (SELECT COUNT(*) FROM players) AS total_players,
  (SELECT COUNT(*) FROM guilds) AS total_guilds,
  (SELECT COUNT(*) FROM alliances) AS total_alliances
`

type GetCountsOfEntitiesRow struct {
	TotalPlayers   int64 `json:"total_players"`
	TotalGuilds    int64 `json:"total_guilds"`
	TotalAlliances int64 `json:"total_alliances"`
}

func (q *Queries) GetCountsOfEntities(ctx context.Context) (GetCountsOfEntitiesRow, error) {
	row := q.db.QueryRow(ctx, getCountsOfEntities)
	var i GetCountsOfEntitiesRow
	err := row.Scan(&i.TotalPlayers, &i.TotalGuilds, &i.TotalAlliances)
	return i, err
}

const getPlayerHistory = `-- name: GetPlayerHistory :many
SELECT
	g.name,
	g.guild_id,
	pgm.first_seen,
	pgm.last_seen,
	COALESCE(
	(
	SELECT
		array_to_json(array_agg(row_to_json(a)))
	FROM
		(
		SELECT
			a.alliance_id,
			a.name,
			a.tag,
			GREATEST(pgm.first_seen, gam.first_seen) AS first_seen,
			LEAST(pgm.last_seen, gam.last_seen) AS last_seen
		FROM
			guild_alliance_memberships gam
		JOIN 
            alliances a ON
			gam.alliance_id = a.alliance_id
			AND gam.region = a.region
		WHERE
			gam.guild_id = g.guild_id
			AND gam.region = g.region
			AND gam.first_seen <= pgm.last_seen
			AND gam.last_seen >= pgm.first_seen
		ORDER BY
			gam.first_seen DESC
		) a
	),
	'[]'::JSON
	) AS alliances
FROM
	player_guild_memberships pgm
JOIN
	guilds g ON
	pgm.guild_id = g.guild_id
	AND pgm.region = g.region
WHERE 
	pgm.player_id = $1
	AND pgm.region = $2
ORDER BY 
	pgm.first_seen DESC
`

type GetPlayerHistoryParams struct {
	PlayerID string `json:"player_id"`
	Region   string `json:"region"`
}

type GetPlayerHistoryRow struct {
	Name      string      `json:"name"`
	GuildID   string      `json:"guild_id"`
	FirstSeen time.Time   `json:"first_seen"`
	LastSeen  time.Time   `json:"last_seen"`
	Alliances interface{} `json:"alliances"`
}

func (q *Queries) GetPlayerHistory(ctx context.Context, arg GetPlayerHistoryParams) ([]GetPlayerHistoryRow, error) {
	rows, err := q.db.Query(ctx, getPlayerHistory, arg.PlayerID, arg.Region)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPlayerHistoryRow{}
	for rows.Next() {
		var i GetPlayerHistoryRow
		if err := rows.Scan(
			&i.Name,
			&i.GuildID,
			&i.FirstSeen,
			&i.LastSeen,
			&i.Alliances,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
