// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package database

import (
	"context"
)

const doesAllianceExist = `-- name: DoesAllianceExist :one
SELECT EXISTS(SELECT 1 FROM alliances WHERE alliance_id = $1 AND region = $2)
`

type DoesAllianceExistParams struct {
	AllianceID string `json:"alliance_id"`
	Region     string `json:"region"`
}

func (q *Queries) DoesAllianceExist(ctx context.Context, arg DoesAllianceExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesAllianceExist, arg.AllianceID, arg.Region)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const doesGuildExist = `-- name: DoesGuildExist :one
SELECT EXISTS(SELECT 1 FROM guilds WHERE guild_id = $1 AND region = $2)
`

type DoesGuildExistParams struct {
	GuildID string `json:"guild_id"`
	Region  string `json:"region"`
}

func (q *Queries) DoesGuildExist(ctx context.Context, arg DoesGuildExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesGuildExist, arg.GuildID, arg.Region)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const doesPlayerExist = `-- name: DoesPlayerExist :one
SELECT EXISTS(SELECT 1 FROM players WHERE player_id = $1 AND region = $2)
`

type DoesPlayerExistParams struct {
	PlayerID string `json:"player_id"`
	Region   string `json:"region"`
}

func (q *Queries) DoesPlayerExist(ctx context.Context, arg DoesPlayerExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, doesPlayerExist, arg.PlayerID, arg.Region)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getCountsOfEntities = `-- name: GetCountsOfEntities :one
SELECT
  (SELECT COUNT(*) FROM players) AS total_players,
  (SELECT COUNT(*) FROM guilds) AS total_guilds,
  (SELECT COUNT(*) FROM alliances) AS total_alliances
`

type GetCountsOfEntitiesRow struct {
	TotalPlayers   int64 `json:"total_players"`
	TotalGuilds    int64 `json:"total_guilds"`
	TotalAlliances int64 `json:"total_alliances"`
}

func (q *Queries) GetCountsOfEntities(ctx context.Context) (GetCountsOfEntitiesRow, error) {
	row := q.db.QueryRow(ctx, getCountsOfEntities)
	var i GetCountsOfEntitiesRow
	err := row.Scan(&i.TotalPlayers, &i.TotalGuilds, &i.TotalAlliances)
	return i, err
}

const getPlayerHistory = `-- name: GetPlayerHistory :one
SELECT 
  (
    SELECT array_to_json(array_agg(row_to_json(g)))
    FROM (
      SELECT 
        pgm.guild_id,
        g.name,
        pgm.first_seen,
        pgm.last_seen,
        (
          SELECT array_to_json(array_agg(row_to_json(a)))
          FROM (
            SELECT 
              gam.alliance_id,
              a.name,
              a.tag,
              GREATEST(pgm.first_seen, gam.first_seen) AS first_seen,
              LEAST(pgm.last_seen, gam.last_seen) AS l
            FROM 
              guild_alliance_memberships gam
            JOIN 
              alliances a ON gam.alliance_id = a.alliance_id AND gam.region = a.region
            WHERE 
              gam.guild_id = g.guild_id AND gam.region = g.region
              AND gam.first_seen <= pgm.last_seen
              AND gam.last_seen >= pgm.first_seen
          ) a
        ) AS alliances
      FROM 
        player_guild_memberships pgm
      JOIN 
        guilds g ON pgm.guild_id = g.guild_id AND pgm.region = g.region
      WHERE 
        pgm.player_id = $1 AND pgm.region = $2
    ) g
  ) AS history
`

type GetPlayerHistoryParams struct {
	PlayerID string `json:"player_id"`
	Region   string `json:"region"`
}

func (q *Queries) GetPlayerHistory(ctx context.Context, arg GetPlayerHistoryParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getPlayerHistory, arg.PlayerID, arg.Region)
	var history []byte
	err := row.Scan(&history)
	return history, err
}
